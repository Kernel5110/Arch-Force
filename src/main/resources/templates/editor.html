<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
    <title>Document Editor</title>
    <link rel="stylesheet" href="/css/styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>

<body>
    <div th:replace="~{fragments/header :: header}"></div>

    <main style="padding: 20px; max-width: 1400px; margin: 0 auto; width: 100%;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <a href="/" class="btn btn-secondary"><i class="fas fa-arrow-left"></i> Back to Dashboard</a>
            <div id="connectionStatus" class="live-indicator">
                <i class="fas fa-circle" style="font-size: 0.5rem;"></i> Live Sync: Active
            </div>
        </div>

        <div id="docHeader"
            style="background: white; padding: 20px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
            <h1 id="docTitle" style="margin: 0; color: var(--primary-color);">Loading...</h1>
            <p id="docMeta" style="color: #666; margin-top: 5px;">Loading...</p>
        </div>

        <div class="editor-container">
            <div class="content-area" id="documentContent">
                <!-- Elements will be rendered here -->
            </div>

            <div class="sidebar">
                <h3>Actions</h3>

                <div class="form-group">
                    <label>Add Element</label>
                    <select id="elementType" onchange="toggleInputs()">
                        <option value="paragraph">Paragraph</option>
                        <option value="heading">Heading</option>
                        <option value="image">Image</option>
                        <option value="list">List</option>
                        <option value="code">Code Block</option>
                        <!-- Table omitted for simplicity for now -->
                    </select>
                </div>

                <div id="paragraphInputs">
                    <textarea id="pContent" placeholder="Enter paragraph content..." rows="5"></textarea>
                </div>

                <div id="headingInputs" style="display:none;">
                    <input type="text" id="headingContent" placeholder="Heading text">
                    <select id="headingLevel">
                        <option value="1">H1</option>
                        <option value="2">H2</option>
                        <option value="3">H3</option>
                        <option value="4">H4</option>
                        <option value="5">H5</option>
                        <option value="6">H6</option>
                    </select>
                </div>

                <div id="imageInputs" style="display:none;">
                    <div style="margin-bottom: 10px;">
                        <label for="imgUpload" style="display: block; margin-bottom: 5px; font-size: 0.9em;">Upload
                            Image(s):</label>
                        <input type="file" id="imgUpload" accept="image/*" multiple onchange="uploadImage()"
                            class="form-control" style="padding: 5px;">
                        <small style="color: #666; font-style: italic;">Select multiple files to add them all at
                            once.</small>
                    </div>
                    <label style="display: block; margin-bottom: 5px; font-size: 0.9em;">Or enter URL:</label>
                    <input type="text" id="imgUrl" placeholder="Image URL">
                    <input type="text" id="imgAlt" placeholder="Alt text">
                </div>

                <div id="listInputs" style="display:none;">
                    <textarea id="listItems" placeholder="Items (comma separated)" rows="5"></textarea>
                    <label><input type="checkbox" id="listOrdered"> Ordered</label>
                </div>

                <div id="codeInputs" style="display:none;">
                    <textarea id="codeContent" placeholder="Paste your code here..." rows="10"
                        style="font-family: monospace;"></textarea>
                    <select id="codeLanguage">
                        <option value="plaintext">Plain Text</option>
                        <option value="java">Java</option>
                        <option value="python">Python</option>
                        <option value="javascript">JavaScript</option>
                        <option value="html">HTML</option>
                        <option value="css">CSS</option>
                        <option value="sql">SQL</option>
                    </select>
                </div>

                <button id="addButton" class="btn btn-primary" onclick="handleAction()"
                    style="width: 100%; margin-top: 10px;">
                    <i class="fas fa-plus"></i> Add
                </button>
                <button id="updateButton" class="btn" onclick="handleAction()"
                    style="width: 100%; margin-top: 10px; display: none; background-color: #28a745;">
                    <i class="fas fa-save"></i> Update
                </button>
                <button id="cancelButton" class="btn btn-secondary" onclick="cancelEdit()"
                    style="width: 100%; margin-top: 10px; display: none;">
                    <i class="fas fa-times"></i> Cancel
                </button>
                <button id="deleteButton" class="btn btn-danger" onclick="deleteElement()"
                    style="width: 100%; margin-top: 10px; display: none; background-color: #dc3545;">
                    <i class="fas fa-trash"></i> Delete Element
                </button>

                <hr style="margin: 20px 0;">

                <h3><i class="fas fa-history"></i> Version History</h3>
                <div class="form-group">
                    <input type="text" id="versionName" placeholder="Commit message (e.g. v1)">
                    <button class="btn" onclick="saveVersion()"
                        style="width: 100%; margin-top: 5px; background-color: #6c757d;">
                        <i class="fas fa-save"></i> Save Version
                    </button>
                </div>

                <hr style="margin: 20px 0;">

                <h3><i class="fas fa-file-export"></i> Export</h3>
                <div class="form-group">
                    <select id="exportFormat">
                        <option value="PDF">PDF Document</option>
                        <option value="HTML">HTML File</option>
                        <option value="Markdown">Markdown File</option>
                    </select>
                    <button class="btn" onclick="exportDocument()"
                        style="width: 100%; margin-top: 5px; background-color: #007bff;">
                        <i class="fas fa-download"></i> Export
                    </button>
                </div>

                <div id="versionList" style="max-height: 300px; overflow-y: auto; margin-top: 10px;">
                    <!-- Versions will be loaded here -->
                </div>
            </div>
        </div>
    </main>

    <div th:replace="~{fragments/footer :: footer}"></div>

    <script th:inline="javascript">
        /*<![CDATA[*/
        const docId = /*[[${documentId}]]*/ 'default';
        /*]]>*/

        let lastVersion = -1;

        async function loadDocument() {
            try {
                const res = await fetch(`/api/documents/${docId}`);
                const data = await res.json();

                if (data.success) {
                    const doc = data.data;

                    // Only update if version changed
                    if (doc.version > lastVersion) {
                        lastVersion = doc.version;

                        document.getElementById('docTitle').innerText = doc.title;
                        document.getElementById('docMeta').innerText = `Author: ${doc.author}`;

                        // Don't re-render if we are currently editing an element to avoid disruption
                        // ideally we'd merge, but for now simple policy:
                        // if user is editing, we show a notification or just don't re-render the list
                        // For this simple requirement "changes load without refresh", we will re-render list
                        // The user editing form is separate from the list display div, so acceptable.
                        renderElements(doc.elements || []);
                    }
                }
            } catch (e) {
                console.error(e);
            }
        }

        // Poll every 1 second for faster updates
        setInterval(loadDocument, 1000);

        let selectedElementId = null;

        function renderElements(elements) {
            const container = document.getElementById('documentContent');
            container.innerHTML = '';

            elements.forEach(el => {
                const elDiv = document.createElement('div');
                elDiv.className = 'document-element';
                elDiv.style.cursor = 'pointer';
                elDiv.onclick = () => selectElement(el);

                let contentHtml = '';
                // Use explicit type check
                if (el.type === 'paragraph') {
                    contentHtml = `<p>${el.content}</p>`;
                } else if (el.type === 'heading') {
                    contentHtml = `<h${el.level}>${el.content}</h${el.level}>`;
                } else if (el.type === 'image') {
                    contentHtml = `<img src="${el.url || el.content}" alt="${el.altText || ''}" style="max-width:100%">`;
                } else if (el.type === 'list') {
                    const tag = el.ordered ? 'ol' : 'ul';
                    const items = el.items.map(i => `<li>${i}</li>`).join('');
                    contentHtml = `<${tag}>${items}</${tag}>`;
                } else if (el.type === 'code') {
                    contentHtml = `<pre style="background:#f4f4f4; padding:10px; border-radius:5px;"><code class="language-${el.language || 'plaintext'}">${escapeHtml(el.content)}</code></pre>`;
                } else {
                    // Fallback for unknown types or if type is missing (legacy)
                    if (el.url) {
                        contentHtml = `<img src="${el.url}" alt="${el.altText || ''}" style="max-width:100%">`;
                    } else if (el.level) {
                        contentHtml = `<h${el.level}>${el.content}</h${el.level}>`;
                    } else if (el.content) {
                        contentHtml = `<p>${el.content}</p>`;
                    } else {
                        contentHtml = `<pre>${JSON.stringify(el, null, 2)}</pre>`;
                    }
                }

                elDiv.innerHTML = contentHtml;
                container.appendChild(elDiv);
            });
        }

        function selectElement(el) {
            selectedElementId = el.id;
            const elementTypeSelect = document.getElementById('elementType');

            // Determine element type and set select value
            // Determine element type and set select value
            if (el.type === 'paragraph') {
                elementTypeSelect.value = 'paragraph';
                document.getElementById('pContent').value = el.content;
            } else if (el.type === 'heading') {
                elementTypeSelect.value = 'heading';
                document.getElementById('headingContent').value = el.content;
                document.getElementById('headingLevel').value = el.level;
            } else if (el.type === 'image') {
                elementTypeSelect.value = 'image';
                document.getElementById('imgUrl').value = el.url || el.content;
                document.getElementById('imgAlt').value = el.altText || '';
            } else if (el.type === 'list') {
                elementTypeSelect.value = 'list';
                document.getElementById('listItems').value = el.items.join(', ');
                document.getElementById('listOrdered').checked = el.ordered;
            } else if (el.type === 'code') {
                elementTypeSelect.value = 'code';
                document.getElementById('codeContent').value = el.content;
                document.getElementById('codeLanguage').value = el.language || 'plaintext';
            } else {
                // Legacy heuristic fallback
                if (el.url) {
                    elementTypeSelect.value = 'image';
                    document.getElementById('imgUrl').value = el.url;
                } else if (el.level) {
                    elementTypeSelect.value = 'heading';
                    document.getElementById('headingContent').value = el.content;
                    document.getElementById('headingLevel').value = el.level;
                } else if (el.content) {
                    elementTypeSelect.value = 'paragraph';
                    document.getElementById('pContent').value = el.content;
                }
            }

            toggleInputs(); // Refresh inputs visibility based on selected type

            // Toggle buttons
            document.getElementById('addButton').style.display = 'none';
            document.getElementById('updateButton').style.display = 'block';
            document.getElementById('cancelButton').style.display = 'block';
            document.getElementById('deleteButton').style.display = 'block';
        }

        function cancelEdit() {
            selectedElementId = null;
            document.getElementById('addButton').style.display = 'block';
            document.getElementById('updateButton').style.display = 'none';
            document.getElementById('cancelButton').style.display = 'none';
            document.getElementById('deleteButton').style.display = 'none';
            clearInputs();
            document.getElementById('elementType').value = 'paragraph'; // Reset select
            toggleInputs(); // Show paragraph inputs by default
        }

        async function deleteElement() {
            if (!confirm('Are you sure you want to delete this element?')) return;

            try {
                const res = await fetch('/api/documents/delete-element', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ documentId: docId, elementId: selectedElementId })
                });

                const data = await res.json();
                if (data.success) {
                    loadDocument();
                    cancelEdit();
                } else {
                    alert('Error deleting: ' + data.message);
                }
            } catch (e) {
                console.error(e);
                alert('Failed to delete element');
            }
        }

        function clearInputs() {
            document.getElementById('pContent').value = '';
            document.getElementById('headingContent').value = '';
            document.getElementById('imgUrl').value = '';
            document.getElementById('imgAlt').value = '';
            document.getElementById('listItems').value = '';
            document.getElementById('listOrdered').checked = false;
            document.getElementById('listOrdered').checked = false;
            document.getElementById('headingLevel').value = '1'; // Reset heading level
            document.getElementById('imgUpload').value = ''; // Reset file input
            document.getElementById('imgUpload').disabled = false; // Enable it back
            document.getElementById('codeContent').value = '';
            document.getElementById('codeLanguage').value = 'plaintext';
        }

        async function uploadImage() {
            const fileInput = document.getElementById('imgUpload');
            const files = fileInput.files;
            if (!files || files.length === 0) return;

            // If multiple files, upload and add them one by one
            if (files.length > 1) {
                if (!confirm(`Upload and add ${files.length} images?`)) {
                    fileInput.value = '';
                    return;
                }

                fileInput.disabled = true;
                const statusLabel = document.getElementById('imgUrl');
                const originalPlaceholder = statusLabel.placeholder;

                let successCount = 0;

                for (let i = 0; i < files.length; i++) {
                    statusLabel.placeholder = `Uploading ${i + 1}/${files.length}...`;
                    const file = files[i];
                    const formData = new FormData();
                    formData.append('file', file);

                    try {
                        const res = await fetch('/api/images/upload', { method: 'POST', body: formData });
                        if (res.ok) {
                            const data = await res.json();
                            // Directly add element
                            let name = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
                            await addImageElement(data.url, name);
                            successCount++;
                        }
                    } catch (e) {
                        console.error("Batch upload error", e);
                    }
                }

                fileInput.disabled = false;
                fileInput.value = '';
                statusLabel.placeholder = originalPlaceholder;
                alert(`Successfully added ${successCount} images.`);
                loadDocument();
                return;
            }

            // Single file logic (existing)
            const file = files[0];
            const formData = new FormData();
            formData.append('file', file);

            // Disable input while uploading
            fileInput.disabled = true;
            document.getElementById('imgUrl').placeholder = "Uploading...";

            try {
                const res = await fetch('/api/images/upload', {
                    method: 'POST',
                    body: formData
                });

                if (res.ok) {
                    const data = await res.json();
                    document.getElementById('imgUrl').value = data.url;

                    // Auto-fill alt text if empty
                    const altInput = document.getElementById('imgAlt');
                    if (!altInput.value) {
                        // Remove extension for alt text
                        let name = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
                        altInput.value = name;
                    }
                } else {
                    const err = await res.json();
                    alert('Upload failed: ' + (err.error || 'Unknown error'));
                    fileInput.value = ''; // Clear selection on error
                }
            } catch (e) {
                console.error(e);
                alert('Upload failed: Network error');
                fileInput.value = '';
            } finally {
                fileInput.disabled = false;
                document.getElementById('imgUrl').placeholder = "Image URL";
            }
        }

        async function addImageElement(url, altText) {
            const body = {
                documentId: docId,
                elementType: 'image',
                elementData: { url: url, altText: altText }
            };

            await fetch('/api/documents/add-element', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
        }

        function toggleInputs() {
            const type = document.getElementById('elementType').value;
            document.getElementById('paragraphInputs').style.display = type === 'paragraph' ? 'block' : 'none';
            document.getElementById('headingInputs').style.display = type === 'heading' ? 'block' : 'none';
            document.getElementById('imageInputs').style.display = type === 'image' ? 'block' : 'none';
            document.getElementById('listInputs').style.display = type === 'list' ? 'block' : 'none';
            document.getElementById('codeInputs').style.display = type === 'code' ? 'block' : 'none';
        }

        function escapeHtml(text) {
            if (!text) return "";
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        async function handleAction() {
            const type = document.getElementById('elementType').value;
            let data = {};

            if (type === 'paragraph') {
                data.content = document.getElementById('pContent').value;
            } else if (type === 'heading') {
                data.content = document.getElementById('headingContent').value;
                data.level = parseInt(document.getElementById('headingLevel').value);
            } else if (type === 'image') {
                data.url = document.getElementById('imgUrl').value;
                data.altText = document.getElementById('imgAlt').value;
            } else if (type === 'list') {
                data.items = document.getElementById('listItems').value.split(',').map(s => s.trim()).filter(s => s !== '');
                data.ordered = document.getElementById('listOrdered').checked;
            } else if (type === 'code') {
                data.content = document.getElementById('codeContent').value;
                data.language = document.getElementById('codeLanguage').value;
            }

            const url = selectedElementId ? '/api/documents/update-element' : '/api/documents/add-element';
            const body = selectedElementId ? {
                documentId: docId,
                elementId: selectedElementId,
                elementData: data
            } : {
                documentId: docId,
                elementType: type,
                elementData: data
            };

            try {
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (res.ok) {
                    loadDocument(); // Reload to see changes
                    cancelEdit(); // Reset state
                } else {
                    const errorData = await res.json();
                    alert('Error: ' + (errorData.message || 'Unknown error'));
                    console.error('Action error:', errorData);
                }
            } catch (e) {
                console.error(e);
                alert('Failed to connect to server');
            }
        }

        // --- Version Control Logic ---

        async function saveVersion() {
            const versionName = document.getElementById('versionName').value;
            if (!versionName) {
                alert('Please enter a version name/message');
                return;
            }

            try {
                const res = await fetch(`/api/versions/create?documentId=${docId}&versionName=${encodeURIComponent(versionName)}`, {
                    method: 'POST'
                });
                const data = await res.json();
                if (data.success) {
                    document.getElementById('versionName').value = '';
                    loadVersions();
                    alert('Version saved!');
                } else {
                    alert('Error: ' + data.message);
                }
            } catch (e) {
                console.error(e);
            }
        }

        async function loadVersions() {
            try {
                const res = await fetch(`/api/versions/list?documentId=${docId}`);
                const data = await res.json();

                if (data.success) {
                    const list = document.getElementById('versionList');
                    list.innerHTML = '';

                    // Sort by time descending (if not already)
                    // data.data is list of maps

                    if (data.data.length === 0) {
                        list.innerHTML = '<p style="color:#888; font-style:italic;">No versions saved.</p>';
                        return;
                    }

                    data.data.forEach(v => {
                        const div = document.createElement('div');
                        div.style.borderBottom = '1px solid #eee';
                        div.style.padding = '8px 0';
                        div.innerHTML = `
                            <div style="font-weight: bold; font-size: 0.9em;">${v.version}</div>
                            <div style="font-size: 0.8em; color: #666;">${new Date(v.snapshotTime).toLocaleString()}</div>
                            <button class="btn btn-sm" onclick="restoreVersion('${v.version}')" style="margin-top:4px; padding: 2px 8px; font-size: 0.8em; background-color: #17a2b8;">
                               <i class="fas fa-undo"></i> Restore
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteVersion('${v.version}')" style="margin-top:4px; padding: 2px 8px; font-size: 0.8em; background-color: #dc3545;">
                               <i class="fas fa-trash"></i> Delete
                            </button>
                        `;
                        list.prepend(div); // Newest first
                    });
                }
            } catch (e) {
                console.error(e);
            }
        }

        async function deleteVersion(version) {
            if (!confirm(`Are you sure you want to delete version "${version}"? This action cannot be undone.`)) return;

            try {
                const res = await fetch(`/api/versions/delete?documentId=${docId}&version=${encodeURIComponent(version)}`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (data.success) {
                    loadVersions();
                    alert('Version deleted!');
                } else {
                    alert('Delete failed: ' + data.message);
                }
            } catch (e) {
                console.error(e);
                alert('Failed to connect to server');
            }
        }
        async function restoreVersion(version) {
            if (!confirm(`Are you sure you want to restore version "${version}"? Current unsaved changes will be overridden.`)) return;

            try {
                const res = await fetch(`/api/versions/restore?documentId=${docId}&version=${encodeURIComponent(version)}`, {
                    method: 'POST'
                });
                const data = await res.json();

                if (data.success) {
                    loadDocument();
                    alert('Version restored!');
                } else {
                    alert('Restoration failed: ' + data.message);
                }
            } catch (e) {
                console.error(e);
            }
        }

        async function exportDocument() {
            const format = document.getElementById('exportFormat').value;
            try {
                const res = await fetch('/api/export/document', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ documentId: docId, format: format })
                });

                const data = await res.json();

                if (data.success) {
                    const contentValues = data.data;
                    const base64Content = contentValues.content;
                    const encoding = contentValues.encoding;

                    if (encoding === 'base64') {
                        downloadBase64File(base64Content, `document.${format.toLowerCase()}`, getMimeType(format));
                    } else {
                        // Fallback for text
                        downloadFile(base64Content, `document.${format.toLowerCase()}`, getMimeType(format));
                    }
                } else {
                    alert('Export failed: ' + data.message);
                }
            } catch (e) {
                console.error(e);
                alert('Export failed');
            }
        }

        function getMimeType(format) {
            switch (format.toLowerCase()) {
                case 'pdf': return 'application/pdf';
                case 'html': return 'text/html';
                case 'markdown': return 'text/markdown';
                default: return 'application/octet-stream';
            }
        }

        function downloadBase64File(base64Data, fileName, mimeType) {
            const linkSource = `data:${mimeType};base64,${base64Data}`;
            const downloadLink = document.createElement("a");
            downloadLink.href = linkSource;
            downloadLink.download = fileName;
            downloadLink.click();
        }

        function downloadFile(content, fileName, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        loadDocument();
        loadVersions(); // Load initial versions
    </script>
</body>

</html>